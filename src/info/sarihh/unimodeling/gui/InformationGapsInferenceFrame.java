package info.sarihh.unimodeling.gui;

import com.rits.cloning.Cloner;
import info.sarihh.unimodeling.streamapi.StreamSource;
import info.sarihh.unimodeling.utility.DatabaseConnectionFactory;
import info.sarihh.unimodeling.utility.ProbRecord;
import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;

/**
 * This class creates the internal frame for the RFID server.
 * Author: Sari Haj Hussein
 */
public class InformationGapsInferenceFrame extends javax.swing.JInternalFrame {

    /**
     * Creates new form RFIDServerFrame
     */
    public InformationGapsInferenceFrame(UniModelingGUI uniModelingGUI) {
        this.unModeingGUI = uniModelingGUI;
        initComponents();
        driversComboBox.setSelectedIndex(1);
        registerStreamDialog.pack();
        connectDatabaseDialog.pack();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        registerStreamDialog = new javax.swing.JDialog();
        infoScrollPane = new javax.swing.JScrollPane();
        infoTextArea = new javax.swing.JTextArea();
        streamEncodingScrollPane = new javax.swing.JScrollPane();
        streamEncodingTextArea = new javax.swing.JTextArea();
        buttonPanel1 = new javax.swing.JPanel();
        okButton = new javax.swing.JButton();
        connectDatabaseDialog = new javax.swing.JDialog();
        driversLabel = new javax.swing.JLabel();
        driversComboBox = new javax.swing.JComboBox();
        urlLabel = new javax.swing.JLabel();
        urlTextField = new javax.swing.JTextField();
        userNameLabel = new javax.swing.JLabel();
        userNameTextField = new javax.swing.JTextField();
        passwordLabel = new javax.swing.JLabel();
        passwordTextField = new javax.swing.JPasswordField();
        buttonPanel2 = new javax.swing.JPanel();
        testButton = new javax.swing.JButton();
        buttonFiller5 = new javax.swing.Box.Filler(new java.awt.Dimension(50, 0), new java.awt.Dimension(50, 0), new java.awt.Dimension(50, 32767));
        okButton1 = new javax.swing.JButton();
        containerScrollPane = new javax.swing.JScrollPane();
        containerPanel = new javax.swing.JPanel();
        algorithmLabel = new javax.swing.JLabel();
        algorithmComboBox = new javax.swing.JComboBox();
        intervalLabel = new javax.swing.JLabel();
        intervalSpinner = new javax.swing.JSpinner();
        activityLogScrollPane = new javax.swing.JScrollPane();
        activityLogTextArea = new javax.swing.JTextArea();
        buttonPanel = new javax.swing.JPanel();
        registerStreamButton = new javax.swing.JButton();
        connectDatabaseButton = new javax.swing.JButton();
        createInferTableButton = new javax.swing.JButton();
        startInferenceButton = new javax.swing.JButton();
        endInferenceButton = new javax.swing.JButton();
        clearLogButton = new javax.swing.JButton();

        registerStreamDialog.setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("info/sarihh/unimodeling/gui/InformationGapsInferenceFrame"); // NOI18N
        registerStreamDialog.setTitle(bundle.getString("InformationGapsInferenceFrame.registerStreamDialog.title_1")); // NOI18N
        registerStreamDialog.setModal(true);
        registerStreamDialog.setResizable(false);
        registerStreamDialog.getContentPane().setLayout(new java.awt.GridBagLayout());

        infoScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        infoTextArea.setBackground(new java.awt.Color(212, 208, 200));
        infoTextArea.setColumns(45);
        infoTextArea.setEditable(false);
        infoTextArea.setLineWrap(true);
        infoTextArea.setRows(10);
        infoTextArea.setText("Specify a string encoding of the stream information in the form:\nregister stream S (obj-id varchar#reader-id integer#time timestamp#...)\nwhere S is the stream name and obj-id, reader-id, and time are attributes of types varchar, integer, and timestamp respectively.\nThe attributes obj-id, reader-id, and time are mandatory.\nThe first two attributes are used for indexing the in-memory hash structure.\nThe third attribute is used to enforce chronological ordering on stream tuples if possible.\nAn arbitrary number of additional attributes can be specified, and there are no restrictions on their types provided that they are supported by the DBMS that will store their values."); // NOI18N
        infoTextArea.setWrapStyleWord(true);
        infoTextArea.setCaretPosition(0);
        infoScrollPane.setViewportView(infoTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        registerStreamDialog.getContentPane().add(infoScrollPane, gridBagConstraints);

        streamEncodingScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        streamEncodingTextArea.setColumns(45);
        streamEncodingTextArea.setFont(new java.awt.Font("Courier New", 0, 11));
        streamEncodingTextArea.setLineWrap(true);
        streamEncodingTextArea.setRows(6);
        streamEncodingTextArea.setText("register stream reading (license_plate varchar2(10 byte)#location_id number(20,0)#reading_ts timestamp(3))"); // NOI18N
        streamEncodingTextArea.setWrapStyleWord(true);
        streamEncodingScrollPane.setViewportView(streamEncodingTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        registerStreamDialog.getContentPane().add(streamEncodingScrollPane, gridBagConstraints);

        okButton.setText(bundle.getString("InformationGapsInferenceFrame.okButton.text_1")); // NOI18N
        okButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okButtonActionPerformed(evt);
            }
        });
        buttonPanel1.add(okButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        registerStreamDialog.getContentPane().add(buttonPanel1, gridBagConstraints);

        connectDatabaseDialog.setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        connectDatabaseDialog.setTitle(bundle.getString("InformationGapsInferenceFrame.connectDatabaseDialog.title_1")); // NOI18N
        connectDatabaseDialog.setModal(true);
        connectDatabaseDialog.setResizable(false);
        connectDatabaseDialog.getContentPane().setLayout(new java.awt.GridBagLayout());

        driversLabel.setText(bundle.getString("InformationGapsInferenceFrame.driversLabel.text_1")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(driversLabel, gridBagConstraints);

        driversComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "MySQL Driver", "Oracle Thin Driver", "PostgreSQL Driver" }));
        driversComboBox.setPreferredSize(new java.awt.Dimension(360, 22));
        driversComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                driversComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(driversComboBox, gridBagConstraints);

        urlLabel.setText(bundle.getString("InformationGapsInferenceFrame.urlLabel.text_1")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(urlLabel, gridBagConstraints);

        urlTextField.setText("jdbc:mysql://<hostname>[,<failoverhost>][<:3306>]/<dbname>"); // NOI18N
        urlTextField.setPreferredSize(new java.awt.Dimension(360, 20));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(urlTextField, gridBagConstraints);

        userNameLabel.setText(bundle.getString("InformationGapsInferenceFrame.userNameLabel.text_1")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(userNameLabel, gridBagConstraints);

        userNameTextField.setPreferredSize(new java.awt.Dimension(360, 20));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(userNameTextField, gridBagConstraints);

        passwordLabel.setText(bundle.getString("InformationGapsInferenceFrame.passwordLabel.text_1")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(passwordLabel, gridBagConstraints);

        passwordTextField.setPreferredSize(new java.awt.Dimension(360, 20));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(passwordTextField, gridBagConstraints);

        testButton.setText(bundle.getString("InformationGapsInferenceFrame.testButton.text_1")); // NOI18N
        testButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                testButtonActionPerformed(evt);
            }
        });
        buttonPanel2.add(testButton);
        buttonPanel2.add(buttonFiller5);

        okButton1.setText(bundle.getString("InformationGapsInferenceFrame.okButton1.text_1")); // NOI18N
        okButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okButton1ActionPerformed(evt);
            }
        });
        buttonPanel2.add(okButton1);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        connectDatabaseDialog.getContentPane().add(buttonPanel2, gridBagConstraints);

        setClosable(true);
        setIconifiable(true);
        setMaximizable(true);
        setResizable(true);
        setTitle(bundle.getString("InformationGapsInferenceFrame.title_1")); // NOI18N

        containerPanel.setLayout(new java.awt.GridBagLayout());

        algorithmLabel.setText(bundle.getString("InformationGapsInferenceFrame.algorithmLabel.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        containerPanel.add(algorithmLabel, gridBagConstraints);

        algorithmComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "DSL_ALG_BN_LAURITZEN", "DSL_ALG_BN_HENRION", "DSL_ALG_BN_PEARL", "DSL_ALG_BN_LSAMPLING", "DSL_ALG_BN_SELFIMPORTANCE", "DSL_ALG_BN_BACKSAMPLING", "DSL_ALG_BN_AISSAMPLING", "DSL_ALG_BN_EPISSAMPLING (Recommended)", "DSL_ALG_BN_LBP", "DSL_ALG_BN_LAURITZEN_OLD" }));
        algorithmComboBox.setSelectedIndex(7);
        algorithmComboBox.setPreferredSize(new java.awt.Dimension(360, 22));
        algorithmComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                algorithmComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        containerPanel.add(algorithmComboBox, gridBagConstraints);

        intervalLabel.setText(bundle.getString("InformationGapsInferenceFrame.intervalLabel.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        containerPanel.add(intervalLabel, gridBagConstraints);

        intervalSpinner.setModel(new SpinnerNumberModel(1, 1, 600, 1));
        javax.swing.JSpinner.NumberEditor editor = new javax.swing.JSpinner.NumberEditor(intervalSpinner, "#");
        editor.getTextField().setHorizontalAlignment(javax.swing.JTextField.LEFT);
        intervalSpinner.setEditor(editor);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        containerPanel.add(intervalSpinner, gridBagConstraints);

        activityLogScrollPane.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle.getString("InformationGapsInferenceFrame.activityLogScrollPane.border.title_1"))); // NOI18N
        activityLogScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        activityLogTextArea.setColumns(40);
        activityLogTextArea.setEditable(false);
        activityLogTextArea.setLineWrap(true);
        activityLogTextArea.setRows(12);
        activityLogTextArea.setWrapStyleWord(true);
        activityLogScrollPane.setViewportView(activityLogTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        containerPanel.add(activityLogScrollPane, gridBagConstraints);

        registerStreamButton.setText(bundle.getString("InformationGapsInferenceFrame.registerStreamButton.text_1")); // NOI18N
        registerStreamButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                registerStreamButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(registerStreamButton);

        connectDatabaseButton.setText(bundle.getString("InformationGapsInferenceFrame.connectDatabaseButton.text_1")); // NOI18N
        connectDatabaseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                connectDatabaseButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(connectDatabaseButton);

        createInferTableButton.setText(bundle.getString("InformationGapsInferenceFrame.createInferTableButton.text_1")); // NOI18N
        createInferTableButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                createInferTableButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(createInferTableButton);

        startInferenceButton.setText(bundle.getString("InformationGapsInferenceFrame.startInferenceButton.text_1")); // NOI18N
        startInferenceButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startInferenceButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(startInferenceButton);

        endInferenceButton.setText(bundle.getString("InformationGapsInferenceFrame.endInferenceButton.text_1")); // NOI18N
        endInferenceButton.setEnabled(false);
        endInferenceButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                endInferenceButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(endInferenceButton);

        clearLogButton.setText(bundle.getString("InformationGapsInferenceFrame.clearLogButton.text_1")); // NOI18N
        clearLogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearLogButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(clearLogButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        containerPanel.add(buttonPanel, gridBagConstraints);

        containerScrollPane.setViewportView(containerPanel);

        getContentPane().add(containerScrollPane, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

private void clearLogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearLogButtonActionPerformed
    activityLogTextArea.setText("");
}//GEN-LAST:event_clearLogButtonActionPerformed

private void endInferenceButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_endInferenceButtonActionPerformed
    processingFlag = false;
}//GEN-LAST:event_endInferenceButtonActionPerformed

private void startInferenceButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startInferenceButtonActionPerformed
    final int interval = (int) intervalSpinner.getValue();
    final int theAlgorithm = algorithmComboBox.getSelectedIndex() + 1;

    Thread inferenceThread = new Thread() {

        @Override
        public void run() {
            try {
                switchButtonState(endInferenceButton, startInferenceButton);
                String[] plates = getLicensePlates();
                String query1 = "SELECT PROB_TABLE.*, "
                        + "(CAST(S_TIME AS DATE) - TO_DATE('19700101','YYYYMMDD')) * 86400 AS S_TIME_UNIX, "
                        + "(CAST(E_TIME AS DATE) - TO_DATE('19700101','YYYYMMDD')) * 86400 AS E_TIME_UNIX "
                        + "FROM PROB_TABLE WHERE LICENSE_PLATE = ? ORDER BY S_TIME, E_TIME";
                PreparedStatement statement1 = conn.prepareStatement(query1, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
                String query2 = "INSERT INTO INFER_TABLE VALUES (?, ?, ?, ?)";
                PreparedStatement statement2 = conn.prepareStatement(query2);
                ResultSet resultSet = null;
                int counter = 0;
                for (String plate : plates) {
                    if (processingFlag) {
                        ++counter;
                        if (counter % 10 == 0) {
                            appendLogText("The information gaps between the readings of " + counter + " objects were inferred.");
                        }
                        statement1.setString(1, plate);
                        resultSet = statement1.executeQuery();
                        ArrayList<ProbRecord> probRecordList = new ArrayList<>();
                        ProbRecord probRecord = null;

                        while (resultSet.next()) {
                            probRecord = new ProbRecord(plate, resultSet.getString("PROB_LOC"),
                                    resultSet.getTimestamp("S_TIME"),
                                    resultSet.getTimestamp("E_TIME"),
                                    resultSet.getLong("S_TIME_UNIX"),
                                    resultSet.getLong("E_TIME_UNIX"));
                            probRecordList.add(probRecord);
                        }

                        StringBuilder param;
                        ProbRecord prec1;
                        ProbRecord prec2;
                        for (int i = 0; i < probRecordList.size() - 1; i++) {
                            param = new StringBuilder();
                            prec1 = probRecordList.get(i);
                            prec2 = probRecordList.get(i + 1);

                            param.append(prec1.getLicensePlate()).append(";").append(
                                    prec1.getProbLoc()).append(";").append(prec1.getsTimeString()).append(
                                    ";").append(prec1.geteTimeString()).append("#");
                            param.append(prec2.getLicensePlate()).append(";").append(
                                    prec2.getProbLoc()).append(";").append(prec2.getsTimeString()).append(
                                    ";").append(prec2.geteTimeString());

                            ProcessBuilder pb = new ProcessBuilder("InferenceEngine.exe", param.toString(),
                                    Integer.toString(interval), Integer.toString(theAlgorithm));
                            pb.directory(new File("."));
                            pb.redirectErrorStream(true);
                            Process process = pb.start();

                            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
                            String line;
                            ArrayList<String> lines = new ArrayList<>();
                            while ((line = br.readLine()) != null) {
                                lines.add(line);
                            }
                            br.close();

                            if (lines.size() == 2) { // only prec1 and prec2
                                // insert prec1
                                String inferRecord = lines.get(0);
                                statement2.setString(1, plate);
                                statement2.setString(2, inferRecord);
                                statement2.setTimestamp(3, prec1.getsTime());
                                statement2.setTimestamp(4, prec1.geteTime());
                                statement2.executeUpdate();
                                if (i == probRecordList.size() - 2) { // insert prec2
                                    inferRecord = lines.get(1);
                                    statement2.setString(1, plate);
                                    statement2.setString(2, inferRecord);
                                    statement2.setTimestamp(3, prec2.getsTime());
                                    statement2.setTimestamp(4, prec2.geteTime());
                                    statement2.executeUpdate();
                                }
                            } else { // prec1, prec2, and the filler
                                // insert prec1
                                String inferRecord = lines.get(0);
                                statement2.setString(1, plate);
                                statement2.setString(2, inferRecord);
                                statement2.setTimestamp(3, prec1.getsTime());
                                statement2.setTimestamp(4, prec1.geteTime());
                                statement2.executeUpdate();
                                // insert the gap filler record
                                long sTimeUnix = prec1.geteTimeUnix() + interval;
                                long eTimeUnix = prec2.getsTimeUnix() - 1;
                                if (sTimeUnix < eTimeUnix) {
                                    inferRecord = lines.get(1);
                                    statement2.setString(1, plate);
                                    statement2.setString(2, inferRecord);
                                    statement2.setTimestamp(3, Timestamp.valueOf(convertUnixTime(conn, sTimeUnix)));
                                    statement2.setTimestamp(4, Timestamp.valueOf(convertUnixTime(conn, eTimeUnix)));
                                    statement2.executeUpdate();
                                }
                                if (i == probRecordList.size() - 2) { // insert prec2
                                    inferRecord = lines.get(2);
                                    statement2.setString(1, plate);
                                    statement2.setString(2, inferRecord);
                                    statement2.setTimestamp(3, prec2.getsTime());
                                    statement2.setTimestamp(4, prec2.geteTime());
                                    statement2.executeUpdate();
                                }
                            }
                            lines.clear();
                        }
                    } else {
                        break;
                    }
                }
                resultSet.close();
                statement1.close();
                statement2.close();
                switchButtonState(startInferenceButton, endInferenceButton);
                appendLogText("The inference ended.");
                appendLogText("The information gaps between the readings of " + counter + " objects were inferred.");
            } catch (Exception e) {
                e.printStackTrace();
                switchButtonState(startInferenceButton, endInferenceButton);
            }
        }
    };
    inferenceThread.start();
}//GEN-LAST:event_startInferenceButtonActionPerformed

private void registerStreamButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_registerStreamButtonActionPerformed
    SwingUtilities.invokeLater(new Runnable() {

        public void run() {
            registerStreamDialog.setLocationRelativeTo(InformationGapsInferenceFrame.this);
            registerStreamDialog.setVisible(true);
        }
    });
}//GEN-LAST:event_registerStreamButtonActionPerformed

private void connectDatabaseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectDatabaseButtonActionPerformed
    SwingUtilities.invokeLater(new Runnable() {

        public void run() {
            connectDatabaseDialog.setLocationRelativeTo(InformationGapsInferenceFrame.this);
            connectDatabaseDialog.setVisible(true);
        }
    });
}//GEN-LAST:event_connectDatabaseButtonActionPerformed

private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed
    String streamEncoding = streamEncodingTextArea.getText();
    streamSource.register(streamEncoding);
    registerStreamDialog.setVisible(false);
    appendLogText("The stream " + streamEncoding.substring(16) + " is registered.");
}//GEN-LAST:event_okButtonActionPerformed

private void testButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_testButtonActionPerformed
    conn = DatabaseConnectionFactory.getDatabaseConnection(
            driversComboBox.getSelectedItem().toString(), urlTextField.getText(),
            userNameTextField.getText(), new String(passwordTextField.getPassword()));
    if (conn != null) {
        JOptionPane.showMessageDialog(InformationGapsInferenceFrame.this,
                "Connection succeeded!",
                "UniModeling",
                JOptionPane.INFORMATION_MESSAGE);
    } else {
        JOptionPane.showMessageDialog(InformationGapsInferenceFrame.this,
                "Connection failed!",
                "UniModeling",
                JOptionPane.ERROR_MESSAGE);
    }
}//GEN-LAST:event_testButtonActionPerformed

private void okButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButton1ActionPerformed
    conn = DatabaseConnectionFactory.getDatabaseConnection(
            driversComboBox.getSelectedItem().toString(), urlTextField.getText(),
            userNameTextField.getText(), new String(passwordTextField.getPassword()));
    if (conn != null) {
        appendLogText("A connection made with the database: "
                + urlTextField.getText() + " using driver: "
                + driversComboBox.getSelectedItem() + ".");
    } else {
        appendLogText("A connection failed with the database: "
                + urlTextField.getText() + " using driver: "
                + driversComboBox.getSelectedItem() + ".");
    }
    connectDatabaseDialog.setVisible(false);
}//GEN-LAST:event_okButton1ActionPerformed

private void createInferTableButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_createInferTableButtonActionPerformed
    createInferTable();
}//GEN-LAST:event_createInferTableButtonActionPerformed

private void algorithmComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_algorithmComboBoxActionPerformed
    switch (algorithmComboBox.getSelectedIndex()) {
        case 0:
            appendLogText("Huang Cecil, and Darwiche, Adnan. (1996) Inference in Belief Networks: A Procedural Guide. International Journal of Approximate Reasoning, 15, 225-263.");
            break;
        case 1:
            appendLogText("Henrion, Max. (1988). Propagating Uncertainty in Bayesian Networks by Probabilistic Logic Sampling. In Lemmer, J.F. and Kanal, L.N. (Eds.) Uncertainty in Artificial Intelligence, 2. North Holland. 149-163.");
            break;
        case 2:
            appendLogText("Judea Pearl. (1986). Fusion, Propagation, and Structuring in Belief Networks. Artificial Intelligence, 29(3), 241-288.");
            break;
        case 3:
            appendLogText("Shachter, Ross D. and Peot, Mark A. (1990). Simulation Approaches to General Probabilistic Inference on Belief Networks. In M. Henrion and R.D. Shachter and L.N. Kanal and J.F. Lemmer (Eds.) Uncertainty in Artificial Intelligence, 5. North Holland. 221-231.");
            break;
        case 4:
            appendLogText("Shachter, Ross D. and Peot, Mark A. (1990). Simulation Approaches to General Probabilistic Inference on Belief Networks. In M. Henrion and R.D. Shachter and L.N. Kanal and J.F. Lemmer (Eds.) Uncertainty in Artificial Intelligence, 5. North Holland. 221-231.");
            break;
        case 5:
            appendLogText("Fung, Robert and Favero, Brendan Del. (1994). Backward Simulation in Bayesian Networks. Proceedings of the Tenth Conference on Uncertainty in Artificial Intelligence, 227-234. San Francisco, CA.");
            break;
        case 6:
            appendLogText("Cheng, Jian and Druzdzel, Marek J. (2000). AIS-BN: An Adaptive Importance Sampling Algorithm for Evidential Reasoning in Large Bayesian Networks. Journal of Artificial Intelligence Research 13(2000) 155-188. Pittsburgh, PA.");
            break;
        case 7:
            appendLogText("Yuan, Changhe and Druzdzel, Marek J. (2003). An Importance Sampling Algorithm Based on Evidence Pre-propagation. In KjÃ¦rulff, U. and Meek, C. (Eds.) Uncertainty in Artificial Intelligence, 19. Acapulco, Mexico. 624-631.");
            break;
        case 8:
            appendLogText("Judea Pearl, (1982) \"Reverend Bayes on inference engines: A distributed hierarchical approach\". Proceedings of the Second National Conference on Artificial Intelligence. AAAI-82: Pittsburgh, PA.");
            break;
        case 9:
            appendLogText("Old implementation of Lauritzen in SMILE. New implementation is much faster and uses less memory. Use this implementation only if you want to verify accuracy of new implementation.");
            break;
        default:
            break;
    }
}//GEN-LAST:event_algorithmComboBoxActionPerformed

private void driversComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_driversComboBoxActionPerformed
    switch (driversComboBox.getSelectedIndex()) {
        case 0:
            urlTextField.setText("jdbc:mysql://<hostname>[,<failoverhost>][<:3306>]/<dbname>");
            userNameTextField.setText("");
            passwordTextField.setText("");
            break;
        case 1:
            urlTextField.setText("jdbc:oracle:thin:@<server>[:<1521>]:<database_name>");
            break;
        case 2:
            urlTextField.setText("jdbc:postgresql:[<//host>[:<5432>/]]<database>");
            userNameTextField.setText("");
            passwordTextField.setText("");
            break;
        default:
            break;
    }
}//GEN-LAST:event_driversComboBoxActionPerformed

    public void appendLogText(final String text) {
        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                if (!text.equals("")) {
                    activityLogTextArea.append(dateFormat.format(new Date()) + " -> " + text + "\n");
                    activityLogTextArea.setCaretPosition(activityLogTextArea.getText().length());
                }
            }
        });
    }

    public StreamSource getStreamSource() {
        return streamSource;
    }

    public Connection getConnection() {
        return conn;
    }

    private void createInferTable() {
        try {
            DatabaseMetaData meta = conn.getMetaData();
            ResultSet resultSet = null;
            String driver = driversComboBox.getSelectedItem().toString();
            if (driver.equals("Oracle Thin Driver")) {
                resultSet = meta.getTables(null, "BAGGAGEQUALITY", null, new String[]{"TABLE"});
            } else {
                resultSet = meta.getTables(null, null, null, new String[]{"TABLE"});
            }
            boolean exist = false;
            while (resultSet.next()) {
                if (resultSet.getString(3).equalsIgnoreCase("INFER_TABLE")) {
                    exist = true;
                    break;
                }
            }
            resultSet.close();

            if (!exist) {
                Cloner cloner = new Cloner();
                HashMap<String, String> streamEncodingMap = cloner.deepClone(streamSource.getStreamEncodingMap());
                String objIDAttributeName = streamSource.getObjIDAttributeName();
                String objIDAttributeType = streamEncodingMap.get(objIDAttributeName);
                String readerIDAttributeName = streamSource.getReaderIDAttributeName();
                String readerIDAttributeType = streamEncodingMap.get(readerIDAttributeName);
                String timeAttributeName = streamSource.getTimeAttributeName();
                streamEncodingMap.remove(objIDAttributeName); // we don't need them anymore in the map
                streamEncodingMap.remove(readerIDAttributeName);
                streamEncodingMap.remove(timeAttributeName);
                StringBuilder sb = new StringBuilder("CREATE TABLE INFER_TABLE (\n");
                sb.append(objIDAttributeName).append(" ").append(objIDAttributeType).append(",\n");
                sb.append("INFER_LOC VARCHAR2(300 BYTE),\n");
                for (String attributeName : streamEncodingMap.keySet()) {
                    sb.append(attributeName).append(" ").append(streamEncodingMap.get(attributeName)).append(",\n");
                }
                sb.append("S_TIME TIMESTAMP (6),\n");
                sb.append("E_TIME TIMESTAMP (6))");
                String query = sb.toString();
                Statement statement = conn.createStatement();
                statement.execute(query);
                statement.close();
                appendLogText("The table INFER_TABLE is created.");
            } else {
                appendLogText("The table INFER_TABLE already exists.");
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

    private String[] getLicensePlates() {
        try {
            String query = "SELECT DISTINCT LICENSE_PLATE FROM PROB_TABLE ORDER BY LICENSE_PLATE";
            Statement statement = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            ResultSet resultSet = statement.executeQuery(query);
            resultSet.last();
            int count = resultSet.getRow();
            resultSet.beforeFirst();
            String[] licensePlates = new String[count];
            int i = 0;
            while (resultSet.next()) {
                licensePlates[i] = resultSet.getString("LICENSE_PLATE");
                i++;
            }
            resultSet.close();
            statement.close();
            return licensePlates;
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
            return null;
        }
    }

    private String convertUnixTime(Connection conn, long unixTime) {
        try {
            String query = "SELECT TO_CHAR(TO_DATE('19700101','YYYYMMDD') + 1/24/60/60 * ?, 'YYYY-MM-DD HH24:MI:SS') FROM DUAL";
            PreparedStatement statement = conn.prepareStatement(query);
            statement.setLong(1, unixTime);
            ResultSet resultSet = statement.executeQuery();
            resultSet.next();
            String converted = resultSet.getString(1);
            resultSet.close();
            statement.close();
            return converted;
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
            return null;
        }
    }

    private void switchButtonState(final JButton button1, final JButton button2) {
        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                button1.setEnabled(true);
                button2.setEnabled(false);
            }
        });
    }
    private UniModelingGUI unModeingGUI = null;
    private static Connection conn = null;
    private SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
    private ServerSocket serverSocket;
    private ConcurrentHashMap<Socket, ObjectOutputStream> clientOutputStreams = new ConcurrentHashMap<>();
    private StreamSource streamSource = new StreamSource();
    private boolean processingFlag = true;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane activityLogScrollPane;
    private static javax.swing.JTextArea activityLogTextArea;
    private javax.swing.JComboBox algorithmComboBox;
    private javax.swing.JLabel algorithmLabel;
    private javax.swing.Box.Filler buttonFiller5;
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JPanel buttonPanel1;
    private javax.swing.JPanel buttonPanel2;
    private javax.swing.JButton clearLogButton;
    private javax.swing.JButton connectDatabaseButton;
    private javax.swing.JDialog connectDatabaseDialog;
    private javax.swing.JPanel containerPanel;
    private javax.swing.JScrollPane containerScrollPane;
    private javax.swing.JButton createInferTableButton;
    private javax.swing.JComboBox driversComboBox;
    private javax.swing.JLabel driversLabel;
    private javax.swing.JButton endInferenceButton;
    private javax.swing.JScrollPane infoScrollPane;
    private static javax.swing.JTextArea infoTextArea;
    private javax.swing.JLabel intervalLabel;
    private javax.swing.JSpinner intervalSpinner;
    private javax.swing.JButton okButton;
    private javax.swing.JButton okButton1;
    private javax.swing.JLabel passwordLabel;
    private javax.swing.JPasswordField passwordTextField;
    private javax.swing.JButton registerStreamButton;
    private javax.swing.JDialog registerStreamDialog;
    private javax.swing.JButton startInferenceButton;
    private javax.swing.JScrollPane streamEncodingScrollPane;
    private static javax.swing.JTextArea streamEncodingTextArea;
    private javax.swing.JButton testButton;
    private javax.swing.JLabel urlLabel;
    private javax.swing.JTextField urlTextField;
    private javax.swing.JLabel userNameLabel;
    private javax.swing.JTextField userNameTextField;
    // End of variables declaration//GEN-END:variables
}
